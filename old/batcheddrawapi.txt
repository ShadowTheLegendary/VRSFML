#pragma once
#include <SFML/Copyright.hpp> // LICENSE AND COPYRIGHT (C) INFORMATION


////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "SFML/Graphics/Export.hpp"

#include "SFML/Graphics/Color.hpp"
#include "SFML/Graphics/IndexType.hpp"
#include "SFML/Graphics/PrimitiveType.hpp"
#include "SFML/Graphics/RenderStates.hpp"

#include "SFML/System/Rect.hpp"
#include "SFML/System/Vector2.hpp"

#include "SFML/Base/InPlacePImpl.hpp"
#include "SFML/Base/SizeT.hpp"
#include "SFML/Base/Traits/IsSame.hpp"


////////////////////////////////////////////////////////////
// Forward declarations
////////////////////////////////////////////////////////////
namespace sf
{
class CPUDrawableBatch;

template <typename TBufferObject>
class GLPersistentBuffer;

class Font;
class PersistentGPUDrawableBatch;
class Shader;
class Shape;
class Text;
class Texture;
class VertexBuffer;

struct ArrowShapeData;
struct CircleShapeData;
struct EllipseShapeData;
struct PieSliceShapeData;
struct RectangleShapeData;
struct RingShapeData;
struct RingPieSliceShapeData;
struct RoundedRectangleShapeData;
struct StarShapeData;

struct BlendMode;
struct GLElementBufferObject;
struct GLVAOGroup;
struct GLVertexBufferObject;
struct Sprite;
struct StencilMode;
struct StencilValue;
struct TextData;
struct Transform;
struct Vertex;
struct View;
} // namespace sf


namespace sf::priv
{
////////////////////////////////////////////////////////////
template <typename T>
concept ShapeDataConcept =                             //
    SFML_BASE_IS_SAME(T, ArrowShapeData) ||            //
    SFML_BASE_IS_SAME(T, CircleShapeData) ||           //
    SFML_BASE_IS_SAME(T, EllipseShapeData) ||          //
    SFML_BASE_IS_SAME(T, PieSliceShapeData) ||         //
    SFML_BASE_IS_SAME(T, RectangleShapeData) ||        //
    SFML_BASE_IS_SAME(T, RingShapeData) ||             //
    SFML_BASE_IS_SAME(T, RingPieSliceShapeData) ||     //
    SFML_BASE_IS_SAME(T, RoundedRectangleShapeData) || //
    SFML_BASE_IS_SAME(T, StarShapeData);

} // namespace sf::priv


namespace sf
{
////////////////////////////////////////////////////////////
/// \brief Base class for all render targets (window, texture, ...)
///
////////////////////////////////////////////////////////////
class [[nodiscard]] SFML_GRAPHICS_API RenderTarget
{
public:
    ////////////////////////////////////////////////////////////
    /// \brief Struct to hold the statistics of a render target
    ///
    ////////////////////////////////////////////////////////////
    struct DrawStatistics
    {
        unsigned int drawCalls{0u}; //!< Number of draw calls
    };

    ////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ////////////////////////////////////////////////////////////
    virtual ~RenderTarget();

    ////////////////////////////////////////////////////////////
    /// \brief Deleted copy constructor
    ///
    ////////////////////////////////////////////////////////////
    RenderTarget(const RenderTarget&) = delete;

    ////////////////////////////////////////////////////////////
    /// \brief Deleted copy assignment
    ///
    ////////////////////////////////////////////////////////////
    RenderTarget& operator=(const RenderTarget&) = delete;

    ////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ////////////////////////////////////////////////////////////
    RenderTarget(RenderTarget&&) noexcept;

    ////////////////////////////////////////////////////////////
    /// \brief Move assignment
    ///
    ////////////////////////////////////////////////////////////
    RenderTarget& operator=(RenderTarget&&) noexcept;

    ////////////////////////////////////////////////////////////
    /// \brief Clear the entire target with a single color
    ///
    /// This function is usually called once every frame,
    /// to clear the previous contents of the target.
    ///
    /// \param color Fill color to use to clear the render target
    ///
    ////////////////////////////////////////////////////////////
    void clear(Color color = Color::Black);

    ////////////////////////////////////////////////////////////
    /// \brief Clear the stencil buffer to a specific value
    ///
    /// The specified value is truncated to the bit width of
    /// the current stencil buffer.
    ///
    /// \param stencilValue Stencil value to clear to
    ///
    ////////////////////////////////////////////////////////////
    void clearStencil(StencilValue stencilValue);

    ////////////////////////////////////////////////////////////
    /// \brief Clear the entire target with a single color and stencil value
    ///
    /// The specified stencil value is truncated to the bit
    /// width of the current stencil buffer.
    ///
    /// \param color        Fill color to use to clear the render target
    /// \param stencilValue Stencil value to clear to
    ///
    ////////////////////////////////////////////////////////////
    void clear(Color color, StencilValue stencilValue);

    ////////////////////////////////////////////////////////////
    /// \brief Change the current active view
    ///
    /// The view is like a 2D camera, it controls which part of
    /// the 2D scene is visible, and how it is viewed in the
    /// render target.
    /// The new view will affect everything that is drawn, until
    /// another view is set.
    /// The render target keeps its own copy of the view object,
    /// so it is not necessary to keep the original one alive
    /// after calling this function.
    ///
    /// \param view New view to use
    ///
    /// \see `getView`
    ///
    ////////////////////////////////////////////////////////////
    void setView(const View& view);

    ////////////////////////////////////////////////////////////
    /// \brief Get the view currently in use in the render target
    ///
    /// \return The view object that is currently used
    ///
    /// \see `setView`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] const View& getView() const;

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    enum class [[nodiscard]] AutoBatchMode : unsigned char
    {
        Disabled,   //!< Auto-batching is disabled
        CPUStorage, //!< Auto-batching is enabled with CPU storage
        GPUStorage, //!< Auto-batching is enabled with GPU storage (fallback to CPU if GPU storage is not available)
    };

    ////////////////////////////////////////////////////////////
    /// \brief Set the current auto-batching mode
    ///
    /// Auto-batching is a performance optimization that groups
    /// draw calls together to reduce the number of state changes
    /// and improve rendering performance. When enabled, the
    /// render target will automatically batch draw calls
    /// together when possible, reducing the overhead of
    /// individual draw calls.
    ///
    /// \param mode The auto-batching mode to set
    ///
    /// \see `getAutoBatchMode`
    ///
    ////////////////////////////////////////////////////////////
    void setAutoBatchMode(AutoBatchMode mode);

    ////////////////////////////////////////////////////////////
    /// \brief Get the current auto-batching mode
    ///
    /// \return The current auto-batching mode
    ///
    /// \see `setAutoBatchMode`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] AutoBatchMode getAutoBatchMode() const;

    ////////////////////////////////////////////////////////////
    /// \brief Set the vertex threshold for auto-batching
    ///
    /// When the current number of vertices in the batch exceeds
    /// this threshold, the batch will be flushed and a new one
    /// will be started. This can help to control the size of
    /// the batches and optimize performance.
    ///
    /// \param threshold The vertex threshold for auto-batching
    ///
    /// \see `getAutoBatchVertexThreshold`
    ///
    ////////////////////////////////////////////////////////////
    void setAutoBatchVertexThreshold(base::SizeT threshold);

    ////////////////////////////////////////////////////////////
    /// \brief Get the vertex threshold for auto-batching
    ///
    /// \return The vertex threshold for auto-batching
    ///
    /// \see `setAutoBatchVertexThreshold`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] base::SizeT getAutoBatchVertexThreshold() const;

    ////////////////////////////////////////////////////////////
    /// \brief Get the viewport of a view, applied to this render target
    ///
    /// The viewport is defined in the view as a ratio, this function
    /// simply applies this ratio to the current dimensions of the
    /// render target to calculate the pixels rectangle that the viewport
    /// actually covers in the target.
    ///
    /// \param view The view for which we want to compute the viewport
    ///
    /// \return Viewport rectangle, expressed in pixels
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] IntRect getViewport(const View& view) const;

    ////////////////////////////////////////////////////////////
    /// \brief Get the scissor rectangle of a view, applied to this render target
    ///
    /// The scissor rectangle is defined in the view as a ratio. This
    /// function simply applies this ratio to the current dimensions
    /// of the render target to calculate the pixels rectangle
    /// that the scissor rectangle actually covers in the target.
    ///
    /// \param view The view for which we want to compute the scissor rectangle
    ///
    /// \return Scissor rectangle, expressed in pixels
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] IntRect getScissor(const View& view) const;

    ////////////////////////////////////////////////////////////
    /// \brief Convert a point from target coordinates to world
    ///        coordinates, using the current view
    ///
    /// This function is an overload of the mapPixelToCoords
    /// function that implicitly uses the current view.
    /// It is equivalent to:
    /// \code
    /// target.mapPixelToCoords(point, target.getView());
    /// \endcode
    ///
    /// \param point Pixel to convert
    ///
    /// \return The converted point, in "world" coordinates
    ///
    /// \see `mapCoordsToPixel`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Vector2f mapPixelToCoords(Vector2i point) const;

    ////////////////////////////////////////////////////////////
    /// \brief Convert a point from target coordinates to world coordinates
    ///
    /// This function finds the 2D position that matches the
    /// given pixel of the render target. In other words, it does
    /// the inverse of what the graphics card does, to find the
    /// initial position of a rendered pixel.
    ///
    /// Initially, both coordinate systems (world units and target pixels)
    /// match perfectly. But if you define a custom view or resize your
    /// render target, this assertion is not `true` anymore, i.e. a point
    /// located at (10, 50) in your render target may map to the point
    /// (150, 75) in your 2D world -- if the view is translated by (140, 25).
    ///
    /// For render-windows, this function is typically used to find
    /// which point (or object) is located below the mouse cursor.
    ///
    /// This version uses a custom view for calculations, see the other
    /// overload of the function if you want to use the current view of the
    /// render target.
    ///
    /// \param point Pixel to convert
    /// \param view The view to use for converting the point
    ///
    /// \return The converted point, in "world" units
    ///
    /// \see `mapCoordsToPixel`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Vector2f mapPixelToCoords(Vector2i point, const View& view) const;

    ////////////////////////////////////////////////////////////
    /// \brief Convert a point from world coordinates to target
    ///        coordinates, using the current view
    ///
    /// This function is an overload of the `mapCoordsToPixel`
    /// function that implicitly uses the current view.
    /// It is equivalent to:
    /// \code
    /// target.mapCoordsToPixel(point, target.getView());
    /// \endcode
    ///
    /// \param point Point to convert
    ///
    /// \return The converted point, in target coordinates (pixels)
    ///
    /// \see `mapPixelToCoords`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Vector2i mapCoordsToPixel(Vector2f point) const;

    ////////////////////////////////////////////////////////////
    /// \brief Convert a point from world coordinates to target coordinates
    ///
    /// This function finds the pixel of the render target that matches
    /// the given 2D point. In other words, it goes through the same process
    /// as the graphics card, to compute the final position of a rendered point.
    ///
    /// Initially, both coordinate systems (world units and target pixels)
    /// match perfectly. But if you define a custom view or resize your
    /// render target, this assertion is not `true` anymore, i.e. a point
    /// located at (150, 75) in your 2D world may map to the pixel
    /// (10, 50) of your render target -- if the view is translated by (140, 25).
    ///
    /// This version uses a custom view for calculations, see the other
    /// overload of the function if you want to use the current view of the
    /// render target.
    ///
    /// \param point Point to convert
    /// \param view The view to use for converting the point
    ///
    /// \return The converted point, in target coordinates (pixels)
    ///
    /// \see `mapPixelToCoords`
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Vector2i mapCoordsToPixel(Vector2f point, const View& view) const;

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    struct TextureDrawParams
    {
        Vector2f position{};      //!< Position of the object in the 2D world
        Vector2f scale{1.f, 1.f}; //!< Scale of the object
        Vector2f origin{};        //!< Origin of translation/rotation/scaling of the object

        // NOLINTNEXTLINE(readability-redundant-member-init)
        Angle rotation{}; //!< Orientation of the object

        FloatRect textureRect{};       //!< Rectangle defining the area of the source texture to display
        Color     color{Color::White}; //!< Color of the sprite
    };

    ////////////////////////////////////////////////////////////
    /// \brief Draw a texture to the render target
    ///
    /// The full texture is drawn at position `{0.f, 0.f}` with default origin,
    /// rotation, scale, and color
    ///
    /// \param sprite Texture to draw
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const Texture& texture, RenderStates states = {}); // TODO P1: RenderStatesWithoutTexture?

    ////////////////////////////////////////////////////////////
    /// \brief Draw a texture to the render target
    ///
    /// \param sprite Texture to draw
    /// \param params Drawing parameters
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const Texture&           texture,
              const TextureDrawParams& params,
              RenderStates             states = {}); // TODO P1: RenderStatesWithoutTexture?

    ////////////////////////////////////////////////////////////
    /// \brief Draw a sprite object to the render target
    ///
    /// The texture associated with a sprite must be passed while drawing.
    ///
    /// \param sprite Sprite to draw
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const Sprite& sprite, const RenderStates& states);

    ////////////////////////////////////////////////////////////
    /// \brief Draw a shape object to the render target
    ///
    /// A texture associated with a shape can be passed while drawing.
    ///
    /// \param shape  Shape to draw
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const Shape& shape, RenderStates states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw a text object to the render target
    ///
    /// \param text Text to draw
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const Text& text, RenderStates states = {});

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void draw(const CPUDrawableBatch& drawableBatch, const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void draw(const PersistentGPUDrawableBatch& drawableBatch, RenderStates states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by a vertex buffer
    ///
    /// \param vertexBuffer Vertex buffer
    /// \param states       Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const VertexBuffer& vertexBuffer, const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by a vertex buffer
    ///
    /// \param vertexBuffer Vertex buffer
    /// \param firstVertex  Index of the first vertex to render
    /// \param vertexCount  Number of vertices to render
    /// \param states       Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void draw(const VertexBuffer& vertexBuffer,
              base::SizeT         firstVertex,
              base::SizeT         vertexCount,
              const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw a shape from its relevant data
    ///
    ////////////////////////////////////////////////////////////
    void draw(const priv::ShapeDataConcept auto& shapeData, const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw a text from a font and its relevant data
    ///
    ////////////////////////////////////////////////////////////
    void draw(const Font& font, const TextData& textData, RenderStates states = {}); // TODO P1: RenderStatesWithoutTexture?

    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by an array of vertices
    ///
    /// \param vertexData  Pointer to the vertices
    /// \param vertexCount Number of vertices in the array
    /// \param type        Type of primitives to draw
    /// \param states      Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void drawVertices(const Vertex* vertexData, base::SizeT vertexCount, PrimitiveType type, const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by an array of indices and vertices
    ///
    /// \param vertexData  Pointer to the vertices
    /// \param vertexCount Number of vertices in the array
    /// \param indexData   Pointer to the indices
    /// \param indexCount  Number of indices in the array
    /// \param type        Type of primitives to draw
    /// \param states      Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void drawIndexedVertices(const Vertex*       vertexData,
                             base::SizeT         vertexCount,
                             const IndexType*    indexData,
                             base::SizeT         indexCount,
                             PrimitiveType       type,
                             const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw quads defined by an array of vertices and precomputed quad indices
    ///
    /// \param vertexData  Pointer to the vertices
    /// \param vertexCount Number of vertices in the array
    /// \param type        Type of primitives to draw
    /// \param states      Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void drawIndexedQuads(const Vertex*       vertexData,
                          base::SizeT         vertexCount,
                          PrimitiveType       type,
                          const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by a persistent mapped buffer and indices
    ///
    /// \param batch        Reference to the persistent mapped buffer
    /// \param indexCount   Number of indices in the array
    /// \param indexOffset  Offset of the first index to use when drawing
    /// \param vertexOffset Offset of the first vertex to use when drawing
    /// \param vertexCount  Number of vertices in the array
    /// \param type         Type of primitives to draw
    /// \param states       Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void drawPersistentMappedIndexedVertices(
        const PersistentGPUDrawableBatch& batch,
        base::SizeT                       indexCount,
        base::SizeT                       indexOffset,
        base::SizeT                       vertexOffset,
        PrimitiveType                     type,
        const RenderStates&               states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Return the size of the rendering region of the target
    ///
    /// \return Size in pixels
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] virtual Vector2u getSize() const = 0;

    ////////////////////////////////////////////////////////////
    /// \brief Tell if the render target will use sRGB encoding when drawing on it
    ///
    /// \return `true` if the render target use sRGB encoding, `false` otherwise
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] virtual bool isSrgb() const;

    ////////////////////////////////////////////////////////////
    /// \brief Activate or deactivate the render target for rendering
    ///
    /// This function makes the render target's context current for
    /// future OpenGL rendering operations (so you shouldn't care
    /// about it if you're not doing direct OpenGL stuff).
    /// A render target's context is active only on the current thread,
    /// if you want to make it active on another thread you have
    /// to deactivate it on the previous thread first if it was active.
    /// Only one context can be current in a thread, so if you
    /// want to draw OpenGL geometry to another render target
    /// don't forget to activate it again. Activating a render
    /// target will automatically deactivate the previously active
    /// context (if any).
    ///
    /// \param active `true` to activate, `false` to deactivate
    ///
    /// \return `true` if operation was successful, `false` otherwise
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] virtual bool setActive(bool active = true);

    ////////////////////////////////////////////////////////////
    /// \brief Reset the internal OpenGL states so that the target is ready for drawing
    ///
    /// This function can be used when you mix SFML drawing
    /// and direct OpenGL rendering. It makes sure that all OpenGL
    /// states needed by SFML are set, so that subsequent `draw()`
    /// calls will work as expected.
    ///
    /// Example:
    /// \code
    /// // OpenGL code here...
    /// glPushAttrib(...);
    /// window.resetGLStates();
    /// window.draw(...);
    /// window.draw(...);
    /// glPopAttrib(...);
    /// // OpenGL code here...
    /// \endcode
    ///
    ////////////////////////////////////////////////////////////
    void resetGLStates();

    ////////////////////////////////////////////////////////////
    /// \brief Draws the currently autobatched drawables (if any)
    ///
    /// \return Statistics about the draw calls that were made
    ///
    ////////////////////////////////////////////////////////////
    RenderTarget::DrawStatistics flush();

protected:
    ////////////////////////////////////////////////////////////
    /// \brief Constructor from view
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] explicit RenderTarget(const View& currentView);

    ////////////////////////////////////////////////////////////
    /// \brief Synchronize the GPU with the CPU (beginning of a frame)
    ///
    /// Only useful when working with persistently mapped buffers.
    ///
    ////////////////////////////////////////////////////////////
    void syncGPUStartFrame();

    ////////////////////////////////////////////////////////////
    /// \brief Synchronize the GPU with the CPU (end of a frame)
    ///
    /// Only useful when working with persistently mapped buffers.
    ///
    ////////////////////////////////////////////////////////////
    void syncGPUEndFrame();

private:
    ////////////////////////////////////////////////////////////
    /// \brief Immediately draw primitives defined by an array of vertices
    ///
    /// Will result in an OpenGL draw call.
    /// Does not flush any batch in-flight.
    ///
    /// \param vertexData  Pointer to the vertices
    /// \param vertexCount Number of vertices in the array
    /// \param type        Type of primitives to draw
    /// \param states      Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void immediateDrawVertices(const Vertex*       vertexData,
                               base::SizeT         vertexCount,
                               PrimitiveType       type,
                               const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Immediately draw primitives defined by an array of indices and vertices
    ///
    /// Will result in an OpenGL draw call.
    /// Does not flush any batch in-flight.
    ///
    /// \param vertexData  Pointer to the vertices
    /// \param vertexCount Number of vertices in the array
    /// \param indexData   Pointer to the indices
    /// \param indexCount  Number of indices in the array
    /// \param type        Type of primitives to draw
    /// \param states      Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void immediateDrawIndexedVertices(const Vertex*       vertexData,
                                      base::SizeT         vertexCount,
                                      const IndexType*    indexData,
                                      base::SizeT         indexCount,
                                      PrimitiveType       type,
                                      const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Immediately draw quads defined by an array of vertices and precomputed quad indices
    ///
    /// Will result in an OpenGL draw call.
    /// Does not flush any batch in-flight.
    /// Indices follow the sequence `[0, 1, 2, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, ...]`.
    /// Vertex count must be a multiple of `4`.
    ///
    /// \param vertexData  Pointer to the vertices
    /// \param vertexCount Number of vertices in the array
    /// \param type        Type of primitives to draw
    /// \param states      Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void immediateDrawIndexedQuads(const Vertex*       vertexData,
                                   base::SizeT         vertexCount,
                                   PrimitiveType       type,
                                   const RenderStates& states = {});

    ////////////////////////////////////////////////////////////
    /// \brief Immediately draw primitives defined by a persistent mapped buffer and indices
    ///
    /// Will result in an OpenGL draw call.
    /// Does not flush any batch in-flight.
    ///
    /// \param batch        Reference to the persistent mapped buffer
    /// \param indexCount   Number of indices in the array
    /// \param indexOffset  Offset of the first index to use when drawing
    /// \param vertexOffset Offset of the first vertex to use when drawing
    /// \param vertexCount  Number of vertices in the array
    /// \param type         Type of primitives to draw
    /// \param states       Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void immediateDrawPersistentMappedIndexedVertices(
        const PersistentGPUDrawableBatch& batch,
        base::SizeT                       indexCount,
        base::SizeT                       indexOffset,
        base::SizeT                       vertexOffset,
        PrimitiveType                     type,
        const RenderStates&               states = {});

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void immediateDrawDrawableBatch(const CPUDrawableBatch& drawableBatch, RenderStates states);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    [[gnu::always_inline]] void flushIfNeeded(const RenderStates& states)
    {
        if (getAutoBatchNumVertices() >= m_autoBatchVertexThreshold || m_lastRenderStates != states)
        {
            flush();
            m_lastRenderStates = states;
        }
    }

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    [[gnu::always_inline]] void flushIfNeededOnlyThreshold()
    {
        if (getAutoBatchNumVertices() >= m_autoBatchVertexThreshold) [[unlikely]]
            flush();
    }

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void resetGLStatesImpl();

    ////////////////////////////////////////////////////////////
    /// \brief Perform common cleaning operations prior to GL calls
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] bool clearImpl();

    ////////////////////////////////////////////////////////////
    /// \brief Apply a view
    ///
    ////////////////////////////////////////////////////////////
    void applyView(const View& view);

    ////////////////////////////////////////////////////////////
    /// \brief Apply a new blending mode
    ///
    /// \param mode Blending mode to apply
    ///
    ////////////////////////////////////////////////////////////
    void applyBlendMode(const BlendMode& mode);

    ////////////////////////////////////////////////////////////
    /// \brief Apply a new stencil mode
    ///
    /// \param mode Stencil mode to apply
    ///
    ////////////////////////////////////////////////////////////
    void applyStencilMode(const StencilMode& mode);

    ////////////////////////////////////////////////////////////
    /// \brief Unbind any bound texture
    ///
    ////////////////////////////////////////////////////////////
    void unapplyTexture();

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    struct DrawGuard;
    friend DrawGuard;

    ////////////////////////////////////////////////////////////
    /// \brief Setup environment for drawing
    ///
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void setupDraw(const GLVAOGroup& vaoGroup, const RenderStates& states);

    ////////////////////////////////////////////////////////////
    /// \brief Setup environment for drawing: MVP matrix
    ///
    /// \param renderStatesTransform Transform to use for the MVP matrix
    /// \param viewTransform         View transform to use for the MVP matrix
    /// \param viewChanged           Whether the view has changed
    /// \param shaderChanged         Whether the shader has changed
    ///
    ////////////////////////////////////////////////////////////
    void setupDrawMVP(const Transform& renderStatesTransform, const Transform& viewTransform, bool viewChanged, bool shaderChanged);

    ////////////////////////////////////////////////////////////
    /// \brief Setup environment for drawing: texture
    ///
    /// \param states Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    void setupDrawTexture(const RenderStates& states);

    ////////////////////////////////////////////////////////////
    /// \brief Clean up environment after drawing
    ///
    /// \param states Render states used for drawing
    ///
    ////////////////////////////////////////////////////////////
    void cleanupDraw(const RenderStates& states);

    ////////////////////////////////////////////////////////////
    /// \brief Invoke primitive draw call: non-indexed
    ///
    /// Immediately executes an OpenGL draw call.
    /// This function is not intended to be used directly.
    /// Does not flush any batch in-flight.
    ///
    /// \param type        Type of primitives to draw
    /// \param firstVertex Index of the first vertex to use when drawing
    /// \param vertexCount Number of vertices to use when drawing
    ///
    ////////////////////////////////////////////////////////////
    void invokePrimitiveDrawCall(PrimitiveType type, base::SizeT firstVertex, base::SizeT vertexCount);

    ////////////////////////////////////////////////////////////
    /// \brief Invoke primitive draw call: indexed
    ///
    /// Immediately executes an OpenGL draw call.
    /// This function is not intended to be used directly.
    /// Does not flush any batch in-flight.
    ///
    /// \param type        Type of primitives to draw
    /// \param indexCount  Number of indices to use when drawing
    /// \param indexOffset Offset of the first index to use when drawing
    ///
    ////////////////////////////////////////////////////////////
    void invokePrimitiveDrawCallIndexed(PrimitiveType type, base::SizeT indexCount, base::SizeT indexOffset);

    ////////////////////////////////////////////////////////////
    /// \brief Invoke primitive draw call: indexed with base vertex (not supported on OpenGL ES 3.1)
    ///
    /// Immediately executes an OpenGL draw call.
    /// This function is not intended to be used directly.
    /// Does not flush any batch in-flight.
    ///
    /// \param type         Type of primitives to draw
    /// \param indexCount   Number of indices to use when drawing
    /// \param indexOffset  Offset of the first index to use when drawing
    /// \param vertexOffset Offset of the first vertex to use when drawing
    ///
    ////////////////////////////////////////////////////////////
    void invokePrimitiveDrawCallIndexedBaseVertex(PrimitiveType type,
                                                  base::SizeT   indexCount,
                                                  base::SizeT   indexOffset,
                                                  base::SizeT   vertexOffset);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void addToAutoBatch(auto&&... xs);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] base::SizeT getAutoBatchNumVertices() const;

public:
    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by a contiguous container of vertices
    ///
    /// \tparam ContiguousVertexRange Type of the contiguous container,
    ///         must support `.data()` and `.size()` operations.
    ///
    /// \param vertices Reference to the contiguous vertex container
    /// \param type     Type of primitives to draw
    /// \param states   Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    template <typename ContiguousVertexRange>
    void draw(const ContiguousVertexRange& vertices, PrimitiveType type, const RenderStates& states = {})
        requires(requires { immediateDrawVertices(vertices.data(), vertices.size(), type, states); })
    {
        drawVertices(vertices.data(), vertices.size(), type, states);
    }

    ////////////////////////////////////////////////////////////
    /// \brief Draw primitives defined by a C-style array of vertices
    ///
    /// \param vertices Reference to the C-style vertex array
    /// \param type     Type of primitives to draw
    /// \param states   Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    template <base::SizeT N>
    void draw(const Vertex (&vertices)[N], PrimitiveType type, const RenderStates& states = {})
    {
        drawVertices(vertices, N, type, states);
    }

    ////////////////////////////////////////////////////////////
    /// \brief Draw a drawable object to the render target
    ///
    /// \tparam DrawableObject Type of the drawable object,
    ///         must support `draw(RenderTarget&, RenderStates&)` method.
    ///
    /// \param drawable Object to draw
    /// \param states   Render states to use for drawing
    ///
    ////////////////////////////////////////////////////////////
    template <typename DrawableObject>
    void draw(const DrawableObject& drawableObject, const RenderStates& states = {})
        requires(requires { drawableObject.draw(*this, states); })
    {
        flushIfNeeded(states);
        drawableObject.draw(*this, states);
    }

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    struct BatchedDrawGuard
    {
        RenderTarget&       renderTarget;
        const RenderStates& renderStates;

        ////////////////////////////////////////////////////////////
        explicit BatchedDrawGuard(RenderTarget& theRenderTarget, const RenderStates& theRenderStates) :
        renderTarget(theRenderTarget),
        renderStates(theRenderStates)
        {
            SFML_BASE_ASSERT(renderTarget.m_autoBatchMode != AutoBatchMode::Disabled);
            renderTarget.flushIfNeeded(renderStates);
        }

        ////////////////////////////////////////////////////////////
        [[gnu::always_inline]] void add(const Sprite& sprite)
        {
            renderTarget.flushIfNeededOnlyThreshold();
            renderTarget.addToAutoBatch(sprite);
        }

        ////////////////////////////////////////////////////////////
        [[gnu::always_inline]] void add(const Shape& shape)
        {
            renderTarget.flushIfNeededOnlyThreshold();
            renderTarget.addToAutoBatch(shape);
        }

        ////////////////////////////////////////////////////////////
        [[gnu::always_inline]] void add(const Text& text)
        {
            renderTarget.flushIfNeededOnlyThreshold();
            renderTarget.addToAutoBatch(text);
        }

        ////////////////////////////////////////////////////////////
        [[gnu::always_inline]] void add(const priv::ShapeDataConcept auto& shapeData)
        {
            renderTarget.flushIfNeededOnlyThreshold();
            renderTarget.addToAutoBatch(shapeData);
        }

        ////////////////////////////////////////////////////////////
        [[gnu::always_inline]] void add(const Font& font, const TextData& textData)
        {
            renderTarget.flushIfNeededOnlyThreshold();
            renderTarget.addToAutoBatch(font, textData);
        }

        ////////////////////////////////////////////////////////////
        [[gnu::always_inline]] void addVertices(const Vertex* const vertexData,
                                                const base::SizeT   vertexCount,
                                                const PrimitiveType type)
        {
            renderTarget.flushIfNeededOnlyThreshold();
            renderTarget.addToAutoBatch(vertexData, vertexCount, type);
        }
    };

    friend BatchedDrawGuard;

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten]] BatchedDrawGuard batchedDraw(const RenderStates& states = {})
    {
        return BatchedDrawGuard{*this, states};
    }

private:
    ////////////////////////////////////////////////////////////
    // Member data
    ////////////////////////////////////////////////////////////
    DrawStatistics m_currentDrawStats{};                       //!< Statistics for current draw calls
    AutoBatchMode  m_autoBatchMode{AutoBatchMode::GPUStorage}; //!< Enable automatic batching of draw calls
    base::SizeT    m_autoBatchVertexThreshold{32'768u};        //!< Threshold for batch vertex count
    RenderStates   m_lastRenderStates;                         //!< Cached render states (autobatching)

    struct Impl;
    base::InPlacePImpl<Impl, 768> m_impl; //!< Implementation details
};

} // namespace sf


////////////////////////////////////////////////////////////
/// \class sf::RenderTarget
/// \ingroup graphics
///
/// `sf::RenderTarget` defines the common behavior of all the
/// 2D render targets usable in the graphics module. It makes
/// it possible to draw 2D entities like sprites, shapes, text
/// without using any OpenGL command directly.
///
/// A `sf::RenderTarget` is also able to use views (`sf::View`),
/// which are a kind of 2D cameras. With views you can globally
/// scroll, rotate or zoom everything that is drawn,
/// without having to transform every single entity. See the
/// documentation of `sf::View` for more details and sample pieces of
/// code about this class.
///
/// On top of that, render targets are still able to render direct
/// OpenGL stuff. It is even possible to mix together OpenGL calls
/// and regular SFML drawing commands. When doing so, make sure that
/// OpenGL states are not messed up by calling `resetGLStates`.
///
/// While render targets are moveable, it is not valid to move them
/// between threads. This will cause your program to crash. The
/// problem boils down to OpenGL being limited with regard to how it
/// works in multithreaded environments. Please ensure you only move
/// render targets within the same thread.
///
/// \see `sf::RenderWindow`, `sf::RenderTexture`, `sf::View`
///
////////////////////////////////////////////////////////////








#include <SFML/Copyright.hpp> // LICENSE AND COPYRIGHT (C) INFORMATION


////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "SFML/Graphics/BlendMode.hpp"
#include "SFML/Graphics/Color.hpp"
#include "SFML/Graphics/DrawableBatch.hpp"
#include "SFML/Graphics/DrawableBatchUtils.hpp"
#include "SFML/Graphics/Font.hpp"
#include "SFML/Graphics/GraphicsContext.hpp"
#include "SFML/Graphics/PrimitiveType.hpp"
#include "SFML/Graphics/RenderStates.hpp"
#include "SFML/Graphics/RenderTarget.hpp"
#include "SFML/Graphics/Shader.hpp"
#include "SFML/Graphics/Shape.hpp"
#include "SFML/Graphics/Sprite.hpp"
#include "SFML/Graphics/StencilMode.hpp"
#include "SFML/Graphics/Text.hpp"
#include "SFML/Graphics/Texture.hpp"
#include "SFML/Graphics/Transform.hpp"
#include "SFML/Graphics/Vertex.hpp"
#include "SFML/Graphics/VertexBuffer.hpp"
#include "SFML/Graphics/View.hpp"

#include "SFML/GLUtils/GLCheck.hpp"
#include "SFML/GLUtils/GLVAOGroup.hpp"
#include "SFML/GLUtils/Glad.hpp"

#include "SFML/System/Err.hpp"
#include "SFML/System/Rect.hpp"

#include "SFML/Base/Algorithm.hpp"
#include "SFML/Base/Assert.hpp"
#include "SFML/Base/Builtins/OffsetOf.hpp"
#include "SFML/Base/FastSinCos.hpp"
#include "SFML/Base/IntTypes.hpp"
#include "SFML/Base/Math/Lround.hpp"
#include "SFML/Base/MinMax.hpp"
#include "SFML/Base/SizeT.hpp"

#include <atomic>


namespace
{
// A nested named namespace is used here to allow unity builds of SFML.
namespace RenderTargetImpl
{
////////////////////////////////////////////////////////////
// Type alias for a render target or context id
using IdType = unsigned int;


////////////////////////////////////////////////////////////
// Unique identifier, used for identifying RenderTargets when
// tracking the currently active RenderTarget within a given context
constinit std::atomic<IdType> nextUniqueId{1ul};


////////////////////////////////////////////////////////////
// Invalid/null render target or context id value
constexpr IdType invalidId{0ul};


////////////////////////////////////////////////////////////
// Maximum supported number of render targets or contexts
constexpr sf::base::SizeT maxIdCount{256ul};


////////////////////////////////////////////////////////////
// Map to help us detect whether a different RenderTarget has been activated within a single context
constinit std::atomic<IdType> contextRenderTargetMap[maxIdCount]{};


////////////////////////////////////////////////////////////
// Check if a render target with the given ID is active in the current context
[[nodiscard]] bool isActive(const IdType contextId, const IdType id)
{
    SFML_BASE_ASSERT(contextId < maxIdCount);

    const auto renderTargetId = contextRenderTargetMap[contextId].load();
    return (renderTargetId != invalidId) && (renderTargetId == id);
}


////////////////////////////////////////////////////////////
#define SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN(fnName, sfEnumType, ...)                                        \
    [[nodiscard, gnu::always_inline, gnu::flatten, gnu::const]] constexpr GLenum fnName(const sfEnumType sfEnumValue) \
    {                                                                                                                 \
        constexpr GLenum glValues[] __VA_ARGS__;                                                                      \
                                                                                                                      \
        SFML_BASE_ASSERT(static_cast<unsigned int>(sfEnumValue) < ::sf::base::getArraySize(glValues));                \
        return glValues[static_cast<unsigned int>(sfEnumValue)];                                                      \
    }


////////////////////////////////////////////////////////////
// Convert an sf::BlendMode::Factor constant to the corresponding OpenGL constant.
SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN(
    factorToGlConstant,
    sf::BlendMode::Factor,
    {GL_ZERO,
     GL_ONE,
     GL_SRC_COLOR,
     GL_ONE_MINUS_SRC_COLOR,
     GL_DST_COLOR,
     GL_ONE_MINUS_DST_COLOR,
     GL_SRC_ALPHA,
     GL_ONE_MINUS_SRC_ALPHA,
     GL_DST_ALPHA,
     GL_ONE_MINUS_DST_ALPHA});


////////////////////////////////////////////////////////////
// Convert an sf::BlendMode::Equation constant to the corresponding OpenGL constant.
SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN(equationToGlConstant,
                                              sf::BlendMode::Equation,
                                              {GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX});


////////////////////////////////////////////////////////////
// Convert an UpdateOperation constant to the corresponding OpenGL constant.
SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN(stencilOperationToGlConstant,
                                              sf::StencilUpdateOperation,
                                              {GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_DECR, GL_INVERT});


////////////////////////////////////////////////////////////
// Convert a Comparison constant to the corresponding OpenGL constant.
SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN(
    stencilFunctionToGlConstant,
    sf::StencilComparison,
    {GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS});


////////////////////////////////////////////////////////////
SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN(
    primitiveTypeToOpenGLMode,
    sf::PrimitiveType,
    {GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN});


////////////////////////////////////////////////////////////
#undef SFML_PRIV_DEFINE_ENUM_TO_GLENUM_CONVERSION_FN

////////////////////////////////////////////////////////////
[[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline sf::IntRect getMultipliedBySizeAndRoundedRect(
    const sf::Vector2u   renderTargetSize,
    const sf::FloatRect& inputRect)
{
    const auto [width, height] = renderTargetSize.toVector2f();

    return sf::Rect<long>({SFML_BASE_MATH_LROUNDF(width * inputRect.position.x),
                           SFML_BASE_MATH_LROUNDF(height * inputRect.position.y)},
                          {SFML_BASE_MATH_LROUNDF(width * inputRect.size.x),
                           SFML_BASE_MATH_LROUNDF(height * inputRect.size.y)})
        .to<sf::IntRect>();
}


////////////////////////////////////////////////////////////
[[gnu::always_inline, gnu::flatten]] inline void streamVerticesToGPU(const sf::Vertex* vertexData, const sf::base::SizeT vertexCount)
{
    glCheck(
        glBufferData(GL_ARRAY_BUFFER, static_cast<GLsizeiptr>(sizeof(sf::Vertex) * vertexCount), vertexData, GL_STREAM_DRAW));
}


////////////////////////////////////////////////////////////
[[gnu::always_inline, gnu::flatten]] inline void streamIndicesToGPU(const sf::IndexType*  indexData,
                                                                    const sf::base::SizeT indexCount)
{
    glCheck(glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                         static_cast<GLsizeiptr>(sizeof(sf::IndexType) * indexCount),
                         indexData,
                         GL_STREAM_DRAW));
}


////////////////////////////////////////////////////////////
void setupVertexAttribPointers()
{
#define SFML_PRIV_OFFSETOF(...) reinterpret_cast<const void*>(SFML_BASE_OFFSETOF(__VA_ARGS__))

    // Hardcoded layout location `0u` for `sf_a_position`
    glCheck(glEnableVertexAttribArray(0u));
    glCheck(glVertexAttribPointer(/*      index */ 0u,
                                  /*       size */ 2,
                                  /*       type */ GL_FLOAT,
                                  /* normalized */ GL_FALSE,
                                  /*     stride */ sizeof(sf::Vertex),
                                  /*     offset */ SFML_PRIV_OFFSETOF(sf::Vertex, position)));

    // Hardcoded layout location `1u` for `sf_a_color`
    glCheck(glEnableVertexAttribArray(1u));
    glCheck(glVertexAttribPointer(/*      index */ 1u,
                                  /*       size */ 4,
                                  /*       type */ GL_UNSIGNED_BYTE,
                                  /* normalized */ GL_TRUE,
                                  /*     stride */ sizeof(sf::Vertex),
                                  /*     offset */ SFML_PRIV_OFFSETOF(sf::Vertex, color)));

    // Hardcoded layout location `2u` for `sf_a_texCoord`
    glCheck(glEnableVertexAttribArray(2u));
    glCheck(glVertexAttribPointer(/*      index */ 2u,
                                  /*       size */ 2,
                                  /*       type */ GL_FLOAT,
                                  /* normalized */ GL_FALSE,
                                  /*     stride */ sizeof(sf::Vertex),
                                  /*     offset */ SFML_PRIV_OFFSETOF(sf::Vertex, texCoords)));

#undef SFML_PRIV_OFFSETOF
}


////////////////////////////////////////////////////////////
constexpr unsigned int precomputedQuadIndices[]{
#include "SFML/Graphics/PrecomputedQuadIndices.inl"
};


#ifndef SFML_OPENGL_ES
////////////////////////////////////////////////////////////
struct [[nodiscard]] PersistentGPUAutoBatchState
{
    enum : sf::base::SizeT
    {
        maxFramesInFlight = 3u //!< Number of frames in flight for GPU autobatching
    };

    sf::base::SizeT indexOffset{0u};  //!< Index offset for GPU autobatching
    sf::base::SizeT vertexOffset{0u}; //!< Vertex offset for GPU autobatching
    sf::base::SizeT numVertices{0u};  //!< Vertex count for GPU autobatching

    GLsync          fences[maxFramesInFlight]{}; //!< Fences for GPU autobatching
    sf::base::SizeT currentFenceIndex{0u};       //!< Cycles `0`, `1`, ..., `maxFramesInFlight - 1`
};
#endif

} // namespace RenderTargetImpl
} // namespace


namespace sf
{
////////////////////////////////////////////////////////////
/// \brief Render states cache
///
////////////////////////////////////////////////////////////
struct [[nodiscard]] StatesCache
{
    bool enable{false};      //!< Is the cache enabled?
    bool glStatesSet{false}; //!< Are our internal GL states set yet?

    bool      viewChanged{false}; //!< Has the current view changed since last draw?
    Transform lastViewTransform;  //!< Cached transform of latest view

    Transform lastRenderStatesTransform; //!< Cached renderstates transform

    bool scissorEnabled{false}; //!< Is scissor testing enabled?
    bool stencilEnabled{false}; //!< Is stencil testing enabled?

    unsigned int lastVaoGroup{0u};          //!< Last bound vertex array object id
    unsigned int lastVaoGroupContextId{0u}; //!< Last bound vertex array object context id

    BlendMode   lastBlendMode{BlendAlpha}; //!< Cached blending mode
    StencilMode lastStencilMode{};         //!< Cached stencil
    base::U64   lastTextureId{0u};         //!< Cached texture

    GLuint lastProgramId{0u}; //!< GL id of the last used shader program
};


////////////////////////////////////////////////////////////
struct [[nodiscard]] RenderTarget::Impl
{
    ////////////////////////////////////////////////////////////
    View                     view;     //!< Current view
    StatesCache              cache{};  //!< Render states cache
    RenderTargetImpl::IdType id{};     //!< Unique number that identifies the render target
    GLVAOGroup               vaoGroup; //!< Associated VAO, VBO, and EBO (non-persistent storage)

    ////////////////////////////////////////////////////////////
    CPUDrawableBatch cpuAutoBatch; //!< Internal CPU autobatch

#ifndef SFML_OPENGL_ES
    PersistentGPUDrawableBatch                    gpuAutoBatch;        //!< Internal GPU autobatch
    RenderTargetImpl::PersistentGPUAutoBatchState gpuAutoBatchState{}; //!< State for GPU autobatching
#endif

    ////////////////////////////////////////////////////////////
    explicit Impl(const View& theView) :
    view(theView),
    id(RenderTargetImpl::nextUniqueId.fetch_add(1u, std::memory_order::relaxed))
    {
    }

    ////////////////////////////////////////////////////////////
    void bindGLObjects(const GLVAOGroup& theVAOGroup)
    {
        theVAOGroup.bind();

        cache.lastVaoGroup          = theVAOGroup.getId();
        cache.lastVaoGroupContextId = GraphicsContext::getActiveThreadLocalGlContextId();

        RenderTargetImpl::setupVertexAttribPointers();
    }
};


////////////////////////////////////////////////////////////
void RenderTarget::addToAutoBatch(auto&&... xs)
{
    SFML_BASE_ASSERT(m_autoBatchMode != AutoBatchMode::Disabled);

#ifdef SFML_OPENGL_ES
    m_impl->cpuAutoBatch.add(SFML_BASE_FORWARD(xs)...);
#else
    if (m_autoBatchMode == AutoBatchMode::CPUStorage)
    {
        m_impl->cpuAutoBatch.add(SFML_BASE_FORWARD(xs)...);
        return;
    }

    SFML_BASE_ASSERT(m_autoBatchMode == AutoBatchMode::GPUStorage);

    const auto prevVertices = m_impl->gpuAutoBatch.getNumVertices();
    m_impl->gpuAutoBatch.add(SFML_BASE_FORWARD(xs)...);
    m_impl->gpuAutoBatchState.numVertices += m_impl->gpuAutoBatch.getNumVertices() - prevVertices;
#endif
}


////////////////////////////////////////////////////////////
template void RenderTarget::addToAutoBatch(const Sprite&);
template void RenderTarget::addToAutoBatch(const Shape&);
template void RenderTarget::addToAutoBatch(const Text&);
template void RenderTarget::addToAutoBatch(const Font&, const TextData&);
template void RenderTarget::addToAutoBatch(const Vertex* const, const base::SizeT, const PrimitiveType);


////////////////////////////////////////////////////////////
base::SizeT RenderTarget::getAutoBatchNumVertices() const
{
    SFML_BASE_ASSERT(m_autoBatchMode != AutoBatchMode::Disabled);

#ifdef SFML_OPENGL_ES
    return m_impl->cpuAutoBatch.getNumVertices();
#else
    if (m_autoBatchMode == AutoBatchMode::CPUStorage)
        return m_impl->cpuAutoBatch.getNumVertices();

    SFML_BASE_ASSERT(m_autoBatchMode == AutoBatchMode::GPUStorage);
    return m_impl->gpuAutoBatchState.numVertices;
#endif
}


////////////////////////////////////////////////////////////
RenderTarget::RenderTarget(const View& currentView) : m_impl(currentView)
{
}


////////////////////////////////////////////////////////////
RenderTarget::~RenderTarget() = default;


////////////////////////////////////////////////////////////
RenderTarget::RenderTarget(RenderTarget&&) noexcept = default;


////////////////////////////////////////////////////////////
RenderTarget& RenderTarget::operator=(RenderTarget&&) noexcept = default;


////////////////////////////////////////////////////////////
[[nodiscard]] bool RenderTarget::clearImpl()
{
    if (!setActive(true))
    {
        priv::err() << "Failed to activate render target in `clearImpl`";
        return false;
    }

    syncGPUStartFrame();

    m_currentDrawStats = {};

    // Unbind texture to fix RenderTexture preventing clear
    unapplyTexture(); // See https://en.sfml-dev.org/forums/index.php?topic=9350

    // Apply the view (scissor testing can affect clearing)
    if (!m_impl->cache.enable || m_impl->cache.viewChanged)
        applyView(m_impl->view);

    return true;
}


////////////////////////////////////////////////////////////
void RenderTarget::clear(const Color color)
{
    if (!clearImpl())
        return;

    glCheck(glClearColor(color.r / 255.f, color.g / 255.f, color.b / 255.f, color.a / 255.f));
    glCheck(glClear(GL_COLOR_BUFFER_BIT));
}


////////////////////////////////////////////////////////////
void RenderTarget::clearStencil(const StencilValue stencilValue)
{
    if (!clearImpl())
        return;

    glCheck(glClearStencil(static_cast<int>(stencilValue.value)));
    glCheck(glClear(GL_STENCIL_BUFFER_BIT));
}


////////////////////////////////////////////////////////////
void RenderTarget::clear(const Color color, const StencilValue stencilValue)
{
    if (!clearImpl())
        return;

    glCheck(glClearColor(color.r / 255.f, color.g / 255.f, color.b / 255.f, color.a / 255.f));
    glCheck(glClearStencil(static_cast<int>(stencilValue.value)));
    glCheck(glClear(GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT));
}


////////////////////////////////////////////////////////////
void RenderTarget::setView(const View& view)
{
    if (view == m_impl->view)
        return;

    flush();

    m_impl->view              = view;
    m_impl->cache.viewChanged = true;
}


////////////////////////////////////////////////////////////
const View& RenderTarget::getView() const
{
    return m_impl->view;
}


////////////////////////////////////////////////////////////
void RenderTarget::setAutoBatchMode(const AutoBatchMode mode)
{
    if (m_autoBatchMode == mode)
        return;

    flush();
    m_autoBatchMode = mode;
}


////////////////////////////////////////////////////////////
RenderTarget::AutoBatchMode RenderTarget::getAutoBatchMode() const
{
    return m_autoBatchMode;
}


////////////////////////////////////////////////////////////
void RenderTarget::setAutoBatchVertexThreshold(const base::SizeT threshold)
{
    if (m_autoBatchVertexThreshold == threshold)
        return;

    flush();
    m_autoBatchVertexThreshold = threshold;
}


////////////////////////////////////////////////////////////
base::SizeT RenderTarget::getAutoBatchVertexThreshold() const
{
    return m_autoBatchVertexThreshold;
}


////////////////////////////////////////////////////////////
IntRect RenderTarget::getViewport(const View& view) const
{
    return RenderTargetImpl::getMultipliedBySizeAndRoundedRect(getSize(), view.viewport);
}


////////////////////////////////////////////////////////////
IntRect RenderTarget::getScissor(const View& view) const
{
    return RenderTargetImpl::getMultipliedBySizeAndRoundedRect(getSize(), view.scissor);
}


////////////////////////////////////////////////////////////
Vector2f RenderTarget::mapPixelToCoords(const Vector2i point) const
{
    return mapPixelToCoords(point, getView());
}


////////////////////////////////////////////////////////////
Vector2f RenderTarget::mapPixelToCoords(const Vector2i point, const View& view) const
{
    // First, convert from viewport coordinates to homogeneous coordinates
    const auto     viewport   = getViewport(view).to<FloatRect>();
    const Vector2f normalized = Vector2f(-1.f, 1.f) + Vector2f(2.f, -2.f)
                                                          .componentWiseMul(point.toVector2f() - viewport.position)
                                                          .componentWiseDiv(viewport.size);

    // Then transform by the inverse of the view matrix
    return view.getInverseTransform().transformPoint(normalized);
}


////////////////////////////////////////////////////////////
Vector2i RenderTarget::mapCoordsToPixel(const Vector2f point) const
{
    return mapCoordsToPixel(point, getView());
}


////////////////////////////////////////////////////////////
Vector2i RenderTarget::mapCoordsToPixel(const Vector2f point, const View& view) const
{
    // First, transform the point by the view matrix
    const Vector2f normalized = view.getTransform().transformPoint(point);

    // Then convert to viewport coordinates
    const auto viewport = getViewport(view).to<FloatRect>();
    return ((normalized.componentWiseMul({1.f, -1.f}) + sf::Vector2f{1.f, 1.f})
                .componentWiseMul({0.5f, 0.5f})
                .componentWiseMul(viewport.size) +
            viewport.position)
        .toVector2i();
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const Texture& texture, RenderStates states)
{
    states.texture = &texture;

    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(Sprite{.textureRect = texture.getRect()});
    }
    else
    {
        Vertex buffer[4];

        appendPreTransformedSpriteVertices(Transform::from(/* position */ {0.f, 0.f},
                                                           /* scale */ {1.f, 1.f},
                                                           /* origin */ {0.f, 0.f}),
                                           texture.getRect(),
                                           Color::White,
                                           buffer);

        draw(buffer, PrimitiveType::TriangleStrip, states);
    }
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const Texture& texture, const TextureDrawParams& params, RenderStates states)
{
    states.texture = &texture;

    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);

        addToAutoBatch(Sprite{
            .position    = params.position,
            .scale       = params.scale,
            .origin      = params.origin,
            .rotation    = params.rotation,
            .textureRect = (params.textureRect == FloatRect{}) ? texture.getRect() : params.textureRect,
            .color       = params.color,
        });
    }
    else
    {
        const auto [sine, cosine] = base::fastSinCos(params.rotation.wrapUnsigned().asRadians());

        Vertex buffer[4];

        appendPreTransformedSpriteVertices(Transform::from(params.position, params.scale, params.origin, sine, cosine),
                                           (params.textureRect == FloatRect{}) ? texture.getRect() : params.textureRect,
                                           params.color,
                                           buffer);

        draw(buffer, PrimitiveType::TriangleStrip, states);
    }
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const Sprite& sprite, const RenderStates& states)
{
    SFML_BASE_ASSERT(states.texture != nullptr);

    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(sprite);
    }
    else
    {
        Vertex buffer[4];
        appendPreTransformedSpriteVertices(sprite.getTransform(), sprite.textureRect, sprite.color, buffer);
        draw(buffer, PrimitiveType::TriangleStrip, states);
    }
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const Shape& shape, RenderStates states)
{
    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(shape);
    }
    else
    {
        states.transform *= shape.getTransform();

        const auto [fillData, fillSize]       = shape.getFillVertices();
        const auto [outlineData, outlineSize] = shape.getOutlineVertices();

        immediateDrawVertices(fillData, fillSize, PrimitiveType::TriangleFan, states);

        if (shape.getOutlineThickness() != 0.f)
            immediateDrawVertices(outlineData, outlineSize, PrimitiveType::TriangleStrip, states);
    }
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const Text& text, RenderStates states)
{
    states.texture = &text.getFont().getTexture();

    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(text);
    }
    else
    {
        text.draw(*this, states);
    }
}


////////////////////////////////////////////////////////////
struct [[nodiscard]] RenderTarget::DrawGuard
{
    RenderTarget&       renderTarget;
    const RenderStates& renderStates; // TODO P1: remove and use lastRenderStates?

    [[nodiscard, gnu::always_inline]] explicit DrawGuard(RenderTarget&       theRenderTarget,
                                                         const RenderStates& theRenderStates,
                                                         const GLVAOGroup&   vaoGroup) :
    renderTarget(theRenderTarget),
    renderStates(theRenderStates)
    {
        renderTarget.setupDraw(vaoGroup, theRenderStates);
    }

    [[gnu::always_inline]] ~DrawGuard()
    {
        SFML_BASE_ASSERT(renderTarget.m_lastRenderStates == renderStates); // TODO P1: remove?
        renderTarget.cleanupDraw(renderStates);
    }
};


////////////////////////////////////////////////////////////
void RenderTarget::immediateDrawVertices(const Vertex* const vertexData,
                                         const base::SizeT   vertexCount,
                                         const PrimitiveType type,
                                         const RenderStates& states)
{
    // Nothing to draw or inactive target
    if (vertexData == nullptr || vertexCount == 0u || !setActive(true))
        return;

    const DrawGuard drawGuard{*this, states, m_impl->vaoGroup};

    RenderTargetImpl::streamVerticesToGPU(vertexData, vertexCount);
    invokePrimitiveDrawCall(type, 0u, vertexCount);
}


////////////////////////////////////////////////////////////
void RenderTarget::immediateDrawIndexedVertices(
    const Vertex* const    vertexData,
    const base::SizeT      vertexCount,
    const IndexType* const indexData,
    const base::SizeT      indexCount,
    const PrimitiveType    type,
    const RenderStates&    states)
{
    // Nothing to draw or inactive target
    if (vertexData == nullptr || vertexCount == 0u || indexData == nullptr || indexCount == 0u || !setActive(true))
        return;

    const DrawGuard drawGuard{*this, states, m_impl->vaoGroup};

    RenderTargetImpl::streamVerticesToGPU(vertexData, vertexCount);
    RenderTargetImpl::streamIndicesToGPU(indexData, indexCount);

    invokePrimitiveDrawCallIndexed(type, indexCount, /* indexOffset */ 0u);
}


////////////////////////////////////////////////////////////
void RenderTarget::immediateDrawIndexedQuads(const Vertex*       vertexData,
                                             const base::SizeT   vertexCount,
                                             const PrimitiveType type,
                                             const RenderStates& states)
{
    SFML_BASE_ASSERT(vertexCount % 4u == 0u);

    immediateDrawIndexedVertices(vertexData, vertexCount, RenderTargetImpl::precomputedQuadIndices, vertexCount / 4u * 6u, type, states);
}


////////////////////////////////////////////////////////////
void RenderTarget::immediateDrawPersistentMappedIndexedVertices(
    [[maybe_unused]] const PersistentGPUDrawableBatch& batch,
    [[maybe_unused]] const base::SizeT                 indexCount,
    [[maybe_unused]] const base::SizeT                 indexOffset,
    [[maybe_unused]] const base::SizeT                 vertexOffset,
    [[maybe_unused]] const PrimitiveType               type,
    [[maybe_unused]] const RenderStates&               states)
{
#ifdef SFML_OPENGL_ES
    priv::err() << "FATAL ERROR: Persistent OpenGL buffers are not available in OpenGL ES";
    base::abort();
#else
    // Nothing to draw or inactive target
    if (indexCount == 0u || !setActive(true))
        return;

    const DrawGuard drawGuard{*this, states, *static_cast<const GLVAOGroup*>(batch.m_storage.getVAOGroup())};

    invokePrimitiveDrawCallIndexedBaseVertex(type, indexCount, indexOffset, vertexOffset);
#endif
}


////////////////////////////////////////////////////////////
void RenderTarget::immediateDrawDrawableBatch(const CPUDrawableBatch& drawableBatch, RenderStates states)
{
    SFML_BASE_ASSERT(drawableBatch.m_storage.indices.size() % 3u == 0u);

    states.transform *= drawableBatch.getTransform();

    immediateDrawIndexedVertices(drawableBatch.m_storage.vertices.data(),
                                 drawableBatch.m_storage.vertices.size(),
                                 drawableBatch.m_storage.indices.data(),
                                 drawableBatch.m_storage.indices.size(),
                                 PrimitiveType::Triangles,
                                 states);
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const CPUDrawableBatch& drawableBatch, const RenderStates& states)
{
    if (m_autoBatchMode != AutoBatchMode::Disabled)
        flush();

    immediateDrawDrawableBatch(drawableBatch, states);
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const PersistentGPUDrawableBatch& drawableBatch, RenderStates states)
{
    if (m_autoBatchMode != AutoBatchMode::Disabled)
        flush();

    states.transform *= drawableBatch.getTransform();

    immediateDrawPersistentMappedIndexedVertices(drawableBatch,
                                                 /* indexCount */ drawableBatch.m_storage.nIndices,
                                                 /* indexOffset */ 0u,
                                                 /* vertexOffset */ 0u,
                                                 PrimitiveType::Triangles,
                                                 states);
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const VertexBuffer& vertexBuffer, const RenderStates& states)
{
    draw(vertexBuffer, 0, vertexBuffer.getVertexCount(), states);
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const VertexBuffer& vertexBuffer,
                        const base::SizeT   firstVertex,
                        base::SizeT         vertexCount,
                        const RenderStates& states)
{
    m_impl->cache.lastVaoGroup = 0u; // Force VAO rebind (TODO P0: why is this needed?)

    if (m_autoBatchMode != AutoBatchMode::Disabled)
        flush();

    // Sanity check
    if (firstVertex > vertexBuffer.getVertexCount())
        return;

    // Clamp vertexCount to something that makes sense
    vertexCount = base::min(vertexCount, vertexBuffer.getVertexCount() - firstVertex);

    // Nothing to draw or inactive target

    if (!vertexCount || !vertexBuffer.getNativeHandle() || !setActive(true))
        return;

    const DrawGuard drawGuard{*this, states, m_impl->vaoGroup};

    // Bind vertex buffer
    vertexBuffer.bind();

    // Always enable texture coordinates (needed because different buffer is bound)
    RenderTargetImpl::setupVertexAttribPointers();

    invokePrimitiveDrawCall(vertexBuffer.getPrimitiveType(), firstVertex, vertexCount);

    // Unbind vertex buffer
    VertexBuffer::unbind();

    // Needed to restore attrib pointers on regular VBO
    m_impl->bindGLObjects(m_impl->vaoGroup);
}


////////////////////////////////////////////////////////////
void RenderTarget::draw(const priv::ShapeDataConcept auto& shapeData, const RenderStates& states)
{
    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(shapeData);
        return;
    }

    SFML_BASE_ASSERT(m_impl->cpuAutoBatch.getNumVertices() == 0u);

    m_impl->cpuAutoBatch.add(shapeData);
    immediateDrawDrawableBatch(m_impl->cpuAutoBatch, states);
    m_impl->cpuAutoBatch.clear();
}


////////////////////////////////////////////////////////////
template void RenderTarget::draw(const ArrowShapeData&, const RenderStates&);
template void RenderTarget::draw(const CircleShapeData&, const RenderStates&);
template void RenderTarget::draw(const EllipseShapeData&, const RenderStates&);
template void RenderTarget::draw(const PieSliceShapeData&, const RenderStates&);
template void RenderTarget::draw(const RectangleShapeData&, const RenderStates&);
template void RenderTarget::draw(const RingShapeData&, const RenderStates&);
template void RenderTarget::draw(const RingPieSliceShapeData&, const RenderStates&);
template void RenderTarget::draw(const RoundedRectangleShapeData&, const RenderStates&);
template void RenderTarget::draw(const StarShapeData&, const RenderStates&);


////////////////////////////////////////////////////////////
void RenderTarget::draw(const Font& font, const TextData& textData, RenderStates states)
{
    states.texture = &font.getTexture();

    if (m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(font, textData);
        return;
    }

    SFML_BASE_ASSERT(m_impl->cpuAutoBatch.getNumVertices() == 0u);

    m_impl->cpuAutoBatch.add(font, textData);
    draw(m_impl->cpuAutoBatch, states);
    m_impl->cpuAutoBatch.clear();
}


////////////////////////////////////////////////////////////
void RenderTarget::drawVertices(const Vertex* const vertexData,
                                const base::SizeT   vertexCount,
                                const PrimitiveType type,
                                const RenderStates& states)
{
    if (type == PrimitiveType::Triangles && m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(vertexData, vertexCount, type);
        return;
    }

    flush();
    immediateDrawVertices(vertexData, vertexCount, type, states);
}


////////////////////////////////////////////////////////////
void RenderTarget::drawIndexedVertices(
    const Vertex* const    vertexData,
    const base::SizeT      vertexCount,
    const IndexType* const indexData,
    const base::SizeT      indexCount,
    const PrimitiveType    type,
    const RenderStates&    states)
{
    if (type == PrimitiveType::Triangles && m_autoBatchMode != AutoBatchMode::Disabled)
    {
        flushIfNeeded(states);
        addToAutoBatch(vertexData, vertexCount, indexData, indexCount, type);
        return;
    }

    flush();
    immediateDrawIndexedVertices(vertexData, vertexCount, indexData, indexCount, type, states);
}


////////////////////////////////////////////////////////////
void RenderTarget::drawIndexedQuads(const Vertex* const vertexData,
                                    const base::SizeT   vertexCount,
                                    const PrimitiveType type,
                                    const RenderStates& states)
{
    SFML_BASE_ASSERT(vertexCount % 4u == 0u);
    drawIndexedVertices(vertexData, vertexCount, RenderTargetImpl::precomputedQuadIndices, vertexCount / 4u * 6u, type, states);
}


////////////////////////////////////////////////////////////
void RenderTarget::drawPersistentMappedIndexedVertices(
    const PersistentGPUDrawableBatch& batch,
    const base::SizeT                 indexCount,
    const base::SizeT                 indexOffset,
    const base::SizeT                 vertexOffset,
    const PrimitiveType               type,
    const RenderStates&               states)
{
    flush();
    immediateDrawPersistentMappedIndexedVertices(batch, indexCount, indexOffset, vertexOffset, type, states);
}


////////////////////////////////////////////////////////////
bool RenderTarget::isSrgb() const
{
    // By default sRGB encoding is not enabled for an arbitrary RenderTarget
    return false;
}


////////////////////////////////////////////////////////////
bool RenderTarget::setActive(const bool active)
{
    // Mark this RenderTarget as active or no longer active in the tracking map
    const RenderTargetImpl::IdType contextId = GraphicsContext::getActiveThreadLocalGlContextId();

    // If this RenderTarget is already active on the current GL context, do nothing
    if (const bool isAlreadyActive = RenderTargetImpl::isActive(contextId, m_impl->id);
        (active && isAlreadyActive) || (!active && !isAlreadyActive))
        return true;

    SFML_BASE_ASSERT(contextId < RenderTargetImpl::maxIdCount);
    std::atomic<RenderTargetImpl::IdType>& renderTargetId = RenderTargetImpl::contextRenderTargetMap[contextId];

    const auto loadedRenderTargetId = renderTargetId.load();

    // Deactivation
    if (!active)
    {
        SFML_BASE_ASSERT(loadedRenderTargetId != RenderTargetImpl::invalidId);
        renderTargetId.store(RenderTargetImpl::invalidId);

        m_impl->cache.enable = false;
        return true;
    }

    // First ever activation or different RT activated on same context
    if (loadedRenderTargetId != m_impl->id)
    {
        renderTargetId.store(m_impl->id);

        if (loadedRenderTargetId == RenderTargetImpl::invalidId)
            m_impl->cache.glStatesSet = false; // First-time activation

        m_impl->cache.enable = false;
        return true;
    }

    // Activation on a different context
    SFML_BASE_ASSERT(loadedRenderTargetId != RenderTargetImpl::invalidId);
    SFML_BASE_ASSERT(loadedRenderTargetId != m_impl->id);
    renderTargetId.store(m_impl->id);

    m_impl->cache.enable = false;
    return true;
}


////////////////////////////////////////////////////////////
void RenderTarget::resetGLStates()
{
    flush();
    resetGLStatesImpl();
}


////////////////////////////////////////////////////////////
void RenderTarget::resetGLStatesImpl()
{
// Workaround for states not being properly reset on
// macOS unless a context switch really takes place
#if defined(SFML_SYSTEM_MACOS)
    if (!setActive(false))
        priv::err() << "Failed to set render target inactive";
#endif

    if (!setActive(true))
        return;

#ifdef SFML_DEBUG
    // Make sure that the user didn't leave an unchecked OpenGL error
    if (const GLenum error = glGetError(); error != GL_NO_ERROR)
        priv::err() << "OpenGL error (" << error << ") detected in user code, you should check for errors with glGetError()";
#endif

    // Make sure that the texture unit which is active is the number 0
    glCheck(glActiveTexture(GL_TEXTURE0));

    // Define the default OpenGL states
    glCheck(glDisable(GL_CULL_FACE));
    glCheck(glDisable(GL_STENCIL_TEST));
    glCheck(glDisable(GL_DEPTH_TEST));
    glCheck(glDisable(GL_SCISSOR_TEST));
    glCheck(glEnable(GL_BLEND));
    glCheck(glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE));

    m_impl->cache.scissorEnabled = false;
    m_impl->cache.stencilEnabled = false;
    m_impl->cache.lastVaoGroup   = 0u;

    m_impl->cache.glStatesSet = true;

    // Apply the default SFML states
    applyBlendMode(BlendAlpha);
    applyStencilMode(StencilMode{});
    unapplyTexture();

    {
        Shader::unbind();
        m_impl->cache.lastProgramId = 0u;
    }

    VertexBuffer::unbind();

    // Set the default view
    setView(getView());

    m_impl->cache.enable = true;
}


////////////////////////////////////////////////////////////
RenderTarget::DrawStatistics RenderTarget::flush()
{
    if (m_autoBatchMode == AutoBatchMode::Disabled)
        return m_currentDrawStats;

#ifdef SFML_OPENGL_ES
    immediateDrawDrawableBatch(m_impl->cpuAutoBatch, m_lastRenderStates);
    m_impl->cpuAutoBatch.clear();
    return m_currentDrawStats;
#else

    if (m_autoBatchMode == AutoBatchMode::CPUStorage)
    {
        immediateDrawDrawableBatch(m_impl->cpuAutoBatch, m_lastRenderStates);
        m_impl->cpuAutoBatch.clear();
        return m_currentDrawStats;
    }

    SFML_BASE_ASSERT(m_autoBatchMode == AutoBatchMode::GPUStorage);

    const auto vertexOffset = m_impl->gpuAutoBatchState.vertexOffset;
    const auto vertexCount  = m_impl->gpuAutoBatch.getNumVertices() - vertexOffset;

    const auto indexOffset = m_impl->gpuAutoBatchState.indexOffset;
    const auto indexCount  = m_impl->gpuAutoBatch.getNumIndices() - indexOffset;

    if (vertexCount == 0u || indexCount == 0u)
        return m_currentDrawStats;

    m_impl->gpuAutoBatch.flushVertexWritesToGPU(vertexCount, vertexOffset);
    m_impl->gpuAutoBatch.flushIndexWritesToGPU(indexCount, indexOffset);

    immediateDrawPersistentMappedIndexedVertices(m_impl->gpuAutoBatch,
                                                 indexCount,
                                                 indexOffset,
                                                 /* vertexOffset */ 0u, // Vertex offset is always `0` for GPU autobatching
                                                 PrimitiveType::Triangles,
                                                 m_lastRenderStates);

    m_impl->gpuAutoBatchState.indexOffset  = m_impl->gpuAutoBatch.getNumIndices();
    m_impl->gpuAutoBatchState.vertexOffset = m_impl->gpuAutoBatch.getNumVertices();
    m_impl->gpuAutoBatchState.numVertices  = 0u;

    return m_currentDrawStats;
#endif
}


////////////////////////////////////////////////////////////
void RenderTarget::syncGPUStartFrame()
{
#ifndef SFML_OPENGL_ES
    auto& fenceToWaitOn = m_impl->gpuAutoBatchState.fences[m_impl->gpuAutoBatchState.currentFenceIndex];

    if (!fenceToWaitOn) // No need to wait
        return;

    // Wait potentially indefinitely...
    // The N-buffering makes stalls *less likely*, but the wait must be blocking for correctness
    const GLenum waitResult = glCheck(glClientWaitSync(fenceToWaitOn, GL_SYNC_FLUSH_COMMANDS_BIT, GL_TIMEOUT_IGNORED));

    if (waitResult == GL_WAIT_FAILED) [[unlikely]]
    {
        priv::err() << "FATAL ERROR: Error waiting on GPU fence";
        base::abort();
    }

    if (waitResult == GL_TIMEOUT_EXPIRED) [[unlikely]]
    {
        priv::err() << "FATAL ERROR: Fence wait timed out";
        base::abort();
    }

    // Delete the fence now that we're done with it
    glCheck(glDeleteSync(fenceToWaitOn));
    fenceToWaitOn = nullptr;
#endif
}


////////////////////////////////////////////////////////////
void RenderTarget::syncGPUEndFrame()
{
#ifndef SFML_OPENGL_ES
    auto& fenceToCreate = m_impl->gpuAutoBatchState.fences[m_impl->gpuAutoBatchState.currentFenceIndex];
    SFML_BASE_ASSERT(fenceToCreate == nullptr);

    fenceToCreate = glCheck(glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0));
    if (fenceToCreate == nullptr) [[unlikely]]
    {
        priv::err() << "FATAL ERROR: Error creating fence sync object";
        base::abort();
    }

    // Advance to the next fence index for the *next* frame
    m_impl->gpuAutoBatchState.currentFenceIndex = (m_impl->gpuAutoBatchState.currentFenceIndex + 1u) %
                                                  RenderTargetImpl::PersistentGPUAutoBatchState::maxFramesInFlight;

    m_impl->gpuAutoBatch.clear();

    m_impl->gpuAutoBatchState.indexOffset  = 0u;
    m_impl->gpuAutoBatchState.vertexOffset = 0u;
    m_impl->gpuAutoBatchState.numVertices  = 0u;
#endif
}


////////////////////////////////////////////////////////////
void RenderTarget::applyView(const View& view)
{
    // Set the viewport
    const IntRect viewport    = getViewport(view);
    const int     viewportTop = static_cast<int>(getSize().y) - (viewport.position.y + viewport.size.y);
    glCheck(glViewport(viewport.position.x, viewportTop, viewport.size.x, viewport.size.y));

    // Set the scissor rectangle and enable/disable scissor testing
    if (view.scissor == FloatRect{{0.f, 0.f}, {1.f, 1.f}})
    {
        if (!m_impl->cache.enable || m_impl->cache.scissorEnabled)
        {
            glCheck(glDisable(GL_SCISSOR_TEST));
            m_impl->cache.scissorEnabled = false;
        }
    }
    else
    {
        const IntRect pixelScissor = getScissor(view);
        const int     scissorTop   = static_cast<int>(getSize().y) - (pixelScissor.position.y + pixelScissor.size.y);

        glCheck(glScissor(pixelScissor.position.x, scissorTop, pixelScissor.size.x, pixelScissor.size.y));

        if (!m_impl->cache.enable || !m_impl->cache.scissorEnabled)
        {
            glCheck(glEnable(GL_SCISSOR_TEST));
            m_impl->cache.scissorEnabled = true;
        }
    }

    m_impl->cache.lastViewTransform = view.getTransform();
    m_impl->cache.viewChanged       = false;
}


////////////////////////////////////////////////////////////
void RenderTarget::applyBlendMode(const BlendMode& mode)
{
    using RenderTargetImpl::equationToGlConstant;
    using RenderTargetImpl::factorToGlConstant;

    glCheck(glBlendFuncSeparate(factorToGlConstant(mode.colorSrcFactor),
                                factorToGlConstant(mode.colorDstFactor),
                                factorToGlConstant(mode.alphaSrcFactor),
                                factorToGlConstant(mode.alphaDstFactor)));

    glCheck(glBlendEquationSeparate(equationToGlConstant(mode.colorEquation), equationToGlConstant(mode.alphaEquation)));

    m_impl->cache.lastBlendMode = mode;
}


////////////////////////////////////////////////////////////
void RenderTarget::applyStencilMode(const StencilMode& mode)
{
    using RenderTargetImpl::stencilFunctionToGlConstant;
    using RenderTargetImpl::stencilOperationToGlConstant;

    m_impl->cache.lastStencilMode = mode;

    // Fast path if we have a default (disabled) stencil mode
    if (mode == StencilMode{})
    {
        if (!m_impl->cache.enable || m_impl->cache.stencilEnabled)
        {
            glCheck(glDisable(GL_STENCIL_TEST));
            glCheck(glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE));

            m_impl->cache.stencilEnabled = false;
        }

        return;
    }

    // Apply the stencil mode
    if (!m_impl->cache.enable || !m_impl->cache.stencilEnabled)
        glCheck(glEnable(GL_STENCIL_TEST));

    glCheck(glStencilOp(GL_KEEP,
                        stencilOperationToGlConstant(mode.stencilUpdateOperation),
                        stencilOperationToGlConstant(mode.stencilUpdateOperation)));

    glCheck(glStencilFunc(stencilFunctionToGlConstant(mode.stencilComparison),
                          static_cast<int>(mode.stencilReference.value),
                          mode.stencilMask.value));

    m_impl->cache.stencilEnabled = true;
}


////////////////////////////////////////////////////////////
void RenderTarget::unapplyTexture()
{
    Texture::unbind();
    m_impl->cache.lastTextureId = 0ul;
}


////////////////////////////////////////////////////////////
void RenderTarget::setupDraw(const GLVAOGroup& vaoGroup, const RenderStates& states)
{
    // GL_FRAMEBUFFER_SRGB is not available on OpenGL ES
    // If a framebuffer supports sRGB, it will always be enabled on OpenGL ES
#ifndef SFML_OPENGL_ES
    // Enable or disable sRGB encoding
    // This is needed for drivers that do not check the format of the surface drawn to before applying sRGB conversion
    if (!m_impl->cache.enable)
    {
        if (isSrgb())
            glCheck(glEnable(GL_FRAMEBUFFER_SRGB));
        else
            glCheck(glDisable(GL_FRAMEBUFFER_SRGB));
    }
#endif

    // First set the persistent OpenGL states if it's the very first call
    if (!m_impl->cache.glStatesSet)
        resetGLStatesImpl();

    // Bind GL objects
    {
        const bool mustRebindVAO = m_impl->cache.lastVaoGroup == 0u || m_impl->cache.lastVaoGroup != vaoGroup.getId() ||
                                   m_impl->cache.lastVaoGroupContextId == 0u ||
                                   m_impl->cache.lastVaoGroupContextId != GraphicsContext::getActiveThreadLocalGlContextId();

        if (!m_impl->cache.enable || mustRebindVAO)
            m_impl->bindGLObjects(vaoGroup);
        else
        {
            // TODO P0: why is this needed??? prevents crash in Render Tests
            RenderTargetImpl::setupVertexAttribPointers();
        }
    }

    // Select shader to be used
    const Shader& usedShader = states.shader != nullptr ? *states.shader : GraphicsContext::getInstalledBuiltInShader();

    // Update shader
    const auto usedNativeHandle = usedShader.getNativeHandle();
    const bool shaderChanged    = !m_impl->cache.enable || m_impl->cache.lastProgramId != usedNativeHandle;

    if (shaderChanged)
    {
        usedShader.bind();
        m_impl->cache.lastProgramId = usedNativeHandle;
    }

    // Apply the view
    const bool viewChanged = !m_impl->cache.enable || m_impl->cache.viewChanged;
    if (viewChanged)
        applyView(m_impl->view);

    // Set the model-view-projection matrix
    setupDrawMVP(states.transform, m_impl->cache.lastViewTransform, viewChanged, shaderChanged);

    // Apply the blend mode
    if (!m_impl->cache.enable || (states.blendMode != m_impl->cache.lastBlendMode))
        applyBlendMode(states.blendMode);

    // Apply the stencil mode
    if (!m_impl->cache.enable || (states.stencilMode != m_impl->cache.lastStencilMode))
        applyStencilMode(states.stencilMode);

    // Mask the color buffer off if necessary
    if (states.stencilMode.stencilOnly)
        glCheck(glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE));

    // Deal with texture
    setupDrawTexture(states);

    // Update last used render states
    m_lastRenderStates = states;
}


////////////////////////////////////////////////////////////
void RenderTarget::setupDrawMVP(const Transform& renderStatesTransform,
                                const Transform& viewTransform,
                                const bool       viewChanged,
                                const bool       shaderChanged)
{
    // If there's no difference from the cached one, exit early
    if (!shaderChanged &&
        (m_impl->cache.enable && !viewChanged && renderStatesTransform == m_impl->cache.lastRenderStatesTransform))
        return;

    // Compute the final draw transform
    const Transform trsfm = viewTransform * /* model-view matrix */ renderStatesTransform;

    // Update the cached transform
    m_impl->cache.lastRenderStatesTransform = renderStatesTransform;

    // clang-format off
    const float transformMatrixBuffer[]{trsfm.a00, trsfm.a10, 0.f, 0.f,
                                        trsfm.a01, trsfm.a11, 0.f, 0.f,
                                        0.f,       0.f,       1.f, 0.f,
                                        trsfm.a02, trsfm.a12, 0.f, 1.f};
    // clang-format on

    // Upload uniform data to GPU (hardcoded layout location `0u` for `sf_u_mvpMatrix`)
    glCheck(glUniformMatrix4fv(/* location */ 0u, /* count */ 1, /* transpose */ GL_FALSE, transformMatrixBuffer));
}


////////////////////////////////////////////////////////////
void RenderTarget::setupDrawTexture(const RenderStates& states)
{
    // Select texture to be used
    const Texture& usedTexture = states.texture != nullptr ? *states.texture
                                                           : GraphicsContext::getInstalledBuiltInWhiteDotTexture();

    // If the texture is an FBO attachment, always rebind it in order to inform the OpenGL driver that we
    // want changes made to it in other contexts to be visible here as well. This saves us from having to
    // call `glFlush()` in `RenderTextureImplFBO` which can be quite costly
    //
    // See: https://www.khronos.org/opengl/wiki/Memory_Model

    // Should the texture be bound?
    const bool mustApplyTexture = !m_impl->cache.enable || usedTexture.m_fboAttachment ||
                                  usedTexture.m_cacheId != m_impl->cache.lastTextureId;

    // If not, exit early
    if (!mustApplyTexture)
        return;

    // Bind the texture
    usedTexture.bind();

    // Update basic cache texture stuff
    m_impl->cache.lastTextureId = usedTexture.m_cacheId;
}


////////////////////////////////////////////////////////////
void RenderTarget::cleanupDraw(const RenderStates& states)
{
    // Do not unbind the shader here, as it could be reused for the next draw call.

    // If the texture we used to draw belonged to a RenderTexture, then forcibly unbind that texture.
    // This prevents a bug where some drivers do not clear RenderTextures properly.
    if (states.texture != nullptr && states.texture->m_fboAttachment)
        unapplyTexture();

    // Mask the color buffer back on if necessary
    if (states.stencilMode.stencilOnly)
        glCheck(glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE));

    // Re-enable the cache at the end of the draw if it was disabled
    m_impl->cache.enable = true;
}


////////////////////////////////////////////////////////////
void RenderTarget::invokePrimitiveDrawCall(const PrimitiveType type, const base::SizeT firstVertex, const base::SizeT vertexCount)
{
    ++m_currentDrawStats.drawCalls;

    glCheck(glDrawArrays(/*     primitive type */ RenderTargetImpl::primitiveTypeToOpenGLMode(type),
                         /* first vertex index */ static_cast<GLint>(firstVertex),
                         /*       vertex count */ static_cast<GLsizei>(vertexCount)));
}


////////////////////////////////////////////////////////////
void RenderTarget::invokePrimitiveDrawCallIndexed(const PrimitiveType type, const base::SizeT indexCount, const base::SizeT indexOffset)
{
    ++m_currentDrawStats.drawCalls;

    glCheck(glDrawElements(/* primitive type */ RenderTargetImpl::primitiveTypeToOpenGLMode(type),
                           /*    index count */ static_cast<GLsizei>(indexCount),
                           /*     index type */ GL_UNSIGNED_INT,
                           /*   index offset */ reinterpret_cast<void*>(indexOffset * sizeof(IndexType))));
}


////////////////////////////////////////////////////////////
void RenderTarget::invokePrimitiveDrawCallIndexedBaseVertex(
    [[maybe_unused]] const PrimitiveType type,
    [[maybe_unused]] const base::SizeT   indexCount,
    [[maybe_unused]] const base::SizeT   indexOffset,
    [[maybe_unused]] const base::SizeT   vertexOffset)
{
#ifdef SFML_OPENGL_ES
    priv::err() << "FATAL ERROR: `glDrawElementsBaseVertex` only available in OpenGL ES 3.2+ (unsupported)";
    base::abort();
#else
    ++m_currentDrawStats.drawCalls;

    glCheck(glDrawElementsBaseVertex(/* primitive type */ RenderTargetImpl::primitiveTypeToOpenGLMode(type),
                                     /*    index count */ static_cast<GLsizei>(indexCount),
                                     /*     index type */ GL_UNSIGNED_INT,
                                     /*   index offset */ reinterpret_cast<void*>(indexOffset * sizeof(IndexType)),
                                     /*    base vertex */ static_cast<GLint>(vertexOffset)));
#endif
}

} // namespace sf

////////////////////////////////////////////////////////////
// Render states caching strategies
//
// * View
//   If SetView was called since last draw, the projection
//   matrix is updated. We don't need more, the view doesn't
//   change frequently.
//
// * Blending mode
//   Since it overloads the == operator, we can easily check
//   whether any of the 6 blending components changed and,
//   thus, whether we need to update the blend mode.
//
// * Texture
//   Storing the pointer or OpenGL ID of the last used texture
//   is not enough; if the sf::Texture instance is destroyed,
//   both the pointer and the OpenGL ID might be recycled in
//   a new texture instance. We need to use our own unique
//   identifier system to ensure consistent caching.
//
// * Shader
//   Shaders are very hard to optimize, because they have
//   parameters that can be hard (if not impossible) to track,
//   like matrices or textures. The only optimization that we
//   do is that we avoid setting a null shader if there was
//   already none for the previous draw.
//
////////////////////////////////////////////////////////////
